<!-- @format -->

# 옵티마이저

-   쿼리는 결과는 동일, 내부적으로 그 결과를 만들어내는 방법은 매우 다양하다.

-   최적, 최소 비용의 방법을 결정해야 한다.

-   각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하며, 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업이 필요하다.

## 쿼리 실행 절차

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.

    - SQL 파싱, MySQL 서버의 SQL 파서라는 모듈로 처리한다

    - SQL 문장이 문법적으로 잘못됐다면 이 단계에서 걸러진다.

    - SQL 파스 트리가 만들어진다.

    - MySQL 서버는 SQL문장이 아니라 SQL 파스 트리를 이용해 쿼리를 실행한다.

2. SQL의 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.

    - SQL 파스 트리를 참조하면서 처리한다.

        - 불필요한 조건 제거 및 복잡한 연산의 단순화

        - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정

        - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정

        - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정

    - 최적화 및 실행 계획 수립 단계, 두 번째 단계가 완료되면 "실행 계획"이 만들어 진다.

3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

    - 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청한다.

    - MySQL 엔진에서는 스톹리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.

## 비용 기반 최적화

-   쿼리를 처리하기 위한 여러가지 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다.

-   산출된 방법별로 비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행한다.

## 기본 데이터 처리

-   MySQL은 데이터를 정렬하거나 그루팡흐는 등의 기본 데이터 가공 기능을 가지고 있다.

### 풀 테이블 스캔과 풀 인덱스 스캔

-   풀 테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다.

-   MySQL 옵티마이저는 다음과 같은 조건일 때 풀 테이블 스캔을 선택한다.
    -   테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우(테이블이 페이지 1개로 구성된 경우)
    -   where 절이나 on 절에 인덱스를 이용할 수 있는 조건이 없는 경우
    -   인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
    -   innoDB는 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다.
        -   리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 요청해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미한다.
        -   풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다.
        -   포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빨리 처리되게 된다.
    -   리드 어헤드는 풀 인덱스 스캔에서도 사용된다.
        -   select count(\*) from employees;
        -   위의 쿼리 처럼 아무런 조건 없이 employees테이블의 레코드 건수를 조회하고 있다.
        -   MySQL 서버는 단순히 레코드의 건수만 필요로 하는 쿼리라면 용량이 작은 인덱스를 선택한다.
        -   select \* from employees같은 레코드에만 있는 컬럼이 필요한 쿼리에는 풀 테이블 스캔이 사용된다.

## order by 처리(Using filesort)

정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 "Filesort"라는 별도의 처리 방법을 이용하는 방법으로 나뉜다.

### 인덱스 이용

장점

-   insert, update, delete쿼리가 실행될 때 이미 인덱스가 정렬되어 있어서 순서대로 읽기만 하면 되므로 매우 빠르다.

단점

-   insert, update, delete 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다.
-   인덱스 때문에 디스크 공간이 더 많이 필요하다.

### Filesort 이용

장점

-   인덱스를 생성하지 않아도 된다. (추가/삭제 작업이 필요없고 디스크 공간이 절약된다.)

단점

-   정렬 작업이 쿼리 실행 시 처리되므로 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.

인덱스를 이용하지않고 정렬 처리가 된 경우엔 실행 게획의 Extra 칼럼에 "Using filesort" 메시지가 표시된다.

## 소트 버퍼

정렬을 수행하기 위해 별도의 메모리 공간을 할당받아 사용 (소트 버퍼)

버퍼의 크기는 가변적으로 증가 (시스템 변수에 설정한 최대 크기 까지)

### 문제점

정렬해야할 레코드가 소트 버퍼에게 할당된 공간보다 클 경우 레코드를 여러 조각으로 나뉘어서 처리하는데 이 과정에서 임시 저장을 위해 디스크를 사용한다.

### 멀티 머지

소트 버퍼에서 정렬 수행 -> 디스크에 임시 저장 -> 다음 레코드 가져와서 정렬처리 후 디스크에 임시 저장

-   각 버퍼 크기만큼 정렬된 레코드를 병합하면서 정렬을 수행해야됨 이러한 작업이 멀티 머지

### 소트 버퍼 크기

소트 버퍼는 세션(로컬) 메모리 영역, 커넥션이 많을수록, 정렬 작업이 많을 수록 소트 버퍼가 차지하는 공간이 커진다.(OOM 주의)

> OOM 발생 시 운영체제의 OOM-Killer가 가장 많은 메모리를 사용하는 MySQL 서버 프로세스를 강제로 종료할 수도 있다.

크기설정에 주의해야한다.

## 정렬 알고리즘

레코드 전체를 소트 버퍼에 담을지, 정렬 기준 컬럼만 소트 버퍼에 담을지에 따라 싱글 패스, 투 패스 2가지 정렬 모드로 나뉜다.

### MySQL 서버의 정렬방식 3가지

-   <sort_key, rowid>: 정렬 키와 레코드의 로우 id만 가져와서 정렬 **(투 패스)**
-   <sort_key, additional_fields>: 정렬 키와 레코드 전체를 가져와서 정렬, 레코드의 컬럼들은 고정 사이즈로 메모리 저장 **(싱글 패스)**
-   <sort_key, packed_additional_fields>: 정렬 키와 레코드 전체를 가져와서 정렬, 레코드의 컬럼들은 가변 사이즈로 메모리 저장 **(싱글 패스)**

## 싱글 패스 정렬 방식

소트 버퍼에 정렬 기준 컬럼을 포함해 select의 대상이 되는 컬럼 전부를 담아서 정렬을 수행하는 방식

## 투 패스 정렬 방식

정렬 대상 컬럼과 키 값만 소트 버퍼에 담아서 정렬 수행 후, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 select할 컬럼을 가져오는 방식

-   투 패스 방식은 테이블을 두 번 읽어야 한다.
-   싱글 패스 방식은 소트 버퍼의 공간이 더 많이 필요하다.

기본적으로 MySQL 서버는 싱글 패스 방식 사용
예외적으로, 다음의 경우 투 패스 방식 사용

-   레코드 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때
-   blob이나 text타입의 컬럼이 select 대상이 될 경우

싱글 패스 방식은 정렬 대상 레코드의 크기나 건수가 작을 경우 효율적, 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 클 경우 효율적이다.

> select 쿼리에서 모든 컬럼(\*)을 가져오도록 할 경우 소트 버퍼를 비효율 적으로 사용하게 된다. 정렬 버퍼 뿐만 아니라 임시 테이블에도 영향을 미치기 때문에 select 쿼리에서는(특히 정렬 쿼리)꼭 필요한 컬럼만 조회하도록 작성하는 것이 좋다.
