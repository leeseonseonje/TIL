## 디스크 읽기 방식
- 데이터 저장 매체(디스크)는 컴퓨터에서 가장 느린 부분이다.

- 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일때가 상당히 많다.

### HDD, SSD
- 하드 디스크는 기계식 장치다. 그래서 데이터베이스 서버에서는 항상 디스크 장치가 병목이 된다.

- 전자식 저장 매체인 SSD가 나왔다.

- SSD는 플래시 메모리를 장착하고 있다. 디스크 원판을 기계적으로 회전시킬 필요가 없으므로 아주 빨리 데이터를 읽고 쓸 수 있다.

- 비휘발성이다.

### 랜덤I/O 순차I/O
- 랜덤I/O는 하드 디스크 드라이브의 원판을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다. 순차 I/O도 이 방식은 똑같다.

- 순차 I/O가 랜덤 I/O보다 약 3배정도 빠르다.

- 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한번에 기록하느냐에 따라 결정된다.

- 인덱스 레인지 스캔은 데이터를 읽기 위해 랜덤I/O를 사용하며 풀 테이블 스캔은 순차I/O를 사용한다. 그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다.

## 인덱스
- DB 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다.

- 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스로 만들어 둔다.

- 인덱스는 칼럼의 값을 주어진 순서로 미리 정렬해서 보관한다.

- 인덱스는 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리다.

- 이미 정렬돼 있어 아주 빨리 원하는 값을 찾아올 수 있다.

- insert, update, delete는 느리지만 select는 매우 빠르게 처리할 수 있다.

- 인덱스는 저장 속도를 희생하고 데이터 읽기 속도를 높이는 기능이다.

- 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하는지에 따라 결정해야 한다.

- where 조건절에 사용되는 컬럼이라고 전부 인덱스로 생성하면 저장 성능이 떨어지기 때문에 주의해야 한다.

- 프라이머리 키와 보조키(세컨더리 인덱스)로 구분할 수 있다.

- 세컨더리 인덱스는 프라이머리 키 외의 인덱스다.

### B-Tree 인덱스

- 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용된다.

- Balanced Tree

- 컬럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.

### 구조 및 특성
- 트리 구조의 최상위에 하나의 "루트 노드"가 존재하고 그 하위에 자식 노드가 붙어 있는 형태다.

- 트리 구조의 가장 하위에 있는 노드를 "리프 노드"라 하고, 트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 중간의 노드를 "브랜치 노드"라고 한다.

- 데이터 베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리 되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.

> InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.

- 인덱스는 키 컬럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다. 이를 위해 인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가진다.

- InnoDB는 세컨더리 인덱스를 통해 레코드를 읽을 때 데이터 파일을 바로 찾아가지 못한다.

- 세컨더리 인덱스 리프 노드에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.

> InnoDB엔진은 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야 한다.

### B-Tree 인덱스 키 추가 및 삭제

- 테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작업이 발생한다.

#### 인덱스 키 추가

- B-Tree에 인덱스가 저장될 때 저장될 키 값을 이용해 저장될 위치를 결정 후 레코드의 키 값과 대상 레코드의 주소 정보를 리프 노드에 저장한다.

- 리프 노드가 꽉 차서 더는 저장할 수 없을 경ㅇ우엔 리프 노드가 분리 돼야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다.

- B-Tree는 위의 작업 탓에 상대적으로 쓰기 작업 비용이 많이 든다.

- 대략적으로 레코드를 추가하는 작업이 1이라고 가정하면 해당 테이블에 인덱스를 추가하는 작업 비용은 1.5 정도가 된다.
  - 인덱스가 하나도 없는 경우 -> 쓰기 비용 1
  - 인덱스 3개 인 경우 -> 5.5

- InnoDB의 경우 새로운 키 값을 인덱스에 반영하는 작업을 지연 시켜 나중에 처리 할 수 있는데, 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제한다.

#### 인덱스 키 삭제

- 삭제 작업은 해당 키 값이 저장된 리프 노드를 찾아서 삭제 마크만 하면 작업이 완료된다.

- 삭제 마킹된 인덱스 키 공간은 그대로 방치하거나, 재활용할 수 있다.

- InnoDB에서는 버퍼링되어 지연 처리 가능하다.

#### 인덱스 키 변경

- 인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 단순히 인덱스상의 키 값만 변경하는 것은 불가능하다.

- 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.

- InnoDB의 체인지 버퍼를 활용해 지연 처리 가능하다.

#### 인덱스 키 검색

- insert, update, delete 작업을 할 때 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 바로 빠른 검색을 위해서다.

- B-Tree인덱스는 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다. (부등호도 가능)

- 키 값의 뒷부분은 불가능, 이미 변형된 값도 불가능(함수나 연산을 수행한 결과 등)

- InnoDB는 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식이기 때문에 update나 delete시에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠글수도 있다.

### B-Tree 인덱스 사용에 영향을 미치는 요소

- B-Tree 인덱스는 인덱스를 구성하는 칼럼의 크기와 레코드의 건수, 그리고 유니크한 인덱스 키 값의 개수 등에 의해 검색이나 변경 작업의 성능이 영향을 받는다.

#### 인덱스 키 값의 크기

- 디스크에 데이터를 저정하는 기본단위 - 페이지

- 버퍼 풀에서 데이터를 버퍼링 하는 기본 단위 - 페이지

- 하나의 인덱스 페이지에 저장할 수 있는 키의 갯수가 제한적이다.

- 만약 select쿼리가 읽어야 할 레코드의 갯수가 하나의 인덱스 페이지에 저장할 수 있는 키의 갯수보다 크다면 그만큼 디스크 IO가 늘어난다.

- 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려지게 된다.

#### B-Tree 깊이

- B-Tree의 깊이는 MySQL에서 값을 검색할 때 몇번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제다.

- 인덱스 키 값의 크기가 커지면 커질수록 하나의 인딕스 페이지가 담을 수 있는 인덱스 키 값의 갯수가 적어지고, 그 때뭄ㄴ에 같은 레코드 건수라 하더라도 B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 된다는 것을 의미한다.

> 실제로 아무리 대용량 데이터베이스라도 뎁스가 5단계 이상까지 깊어지는 경우는 흔치 않다.

#### 기수성

- 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.

- 전체 인덱스 키 값은 100개인데, 그 중에서 유니크한 값의 수는 10개라면 기수성은 10이다.

- 인덱스 키 값 가운데 중복된 값이 많아지면 많아질수록 기수성은 낮아지고, 선택도도 떨어진다.

- 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.

```
10000건의 레코드 중
A: 컬럼1의 유니크한 값이 10개 일 경우
B: 컬럼1의 유니크한 값이 1000개 일 경우
select * from table where col1 = '1' and col2 = 'b'
A의 경우 평균 1000건, B의 경우 10건을 조회하게 된다. 
같은 결과를 조회하는 쿼리를 실행하더라 쿼리가 처리되기 위해 MySQL 서버가 수행한 작업 내용은 다르다.
인덱스에서 유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미친다. 
```

#### 읽어야 하는 레코드의 건수

- 인덱스를 통해 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다.

- 전체 테이블을 모두 읽어서 필요 없는 데이터를 버리는 것과, 인덱스를 통해 필요한 데이터만 읽어오는 것 중 뭐가 더 효율적인지 판단해야 한다.

- 일반적으로 인덱스로 1건 읽는 것이 테이블에서 직접 1건 읽는 것 보다 4~5배 정도 많은 비용이 든다.

- 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 읽어서 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적이다.

- MySQL 옵티마이저가 선택해준다.

### 인덱스 레인지 스캔

 - 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.

 - 루트, 브랜치 노드를 이용해 스캔 시작 위치를 검색하고, 필요한 방향으로 인덱스를 읽어 나간다.

 - 어떤 방식으로 스캔하든 관계없이, 해당 인덱스를 구성하는 칼럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온다. (인덱스 자체 정렬)

 - 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다.

 - 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어 올 때, 한 건 한 건 단위로 랜덤 I/O가 일어난다.

 - 인덱스를 통해 레코드를 읽는 작업은 비용이 많이 드는 작업이다.
```
인덱스 레인지 스캔 3단계
1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. (인덱스 탐색)
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다. (인덱스 스캔)
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어 온다.
```

- 커버링 인덱스의 경우 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 줄어든다.

### 인덱스 풀 스캔

- 인덱스를 처음부터 끝까지 모두 읽는 방식

- 대표적으로 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.

> 인덱스(a, b, c) where = b, c

- 쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우 사용된다.

- 데이터 레코드 까지 읽어야 한다면 절대 이 방식으로 처리되지 않는다.

### 루스 인덱스 스캔

- 인덱스 레인지 스캔과 비슷하지만 중간에 필요치 않은 인덱스 키 값은 무시하고 넘어가는 형태로 처리한다.

- group by, max, min 함수에 대해 최적화 하는 경우에 사용된다.

### 인덱스 스캡 스캔

- 인덱스의 핵심은 값이 정렬돼 있다는 것이며, 이로 인해 인덱스르 구성하는 컬럼의 순서는 매우 중요하다.

- 선행 인덱스 컬럼을 조건절에서 사용하지 않으면 인덱스를 사용할 수 없게 된다. (풀 인덱스 스캔)

- 옵티마이저가 선행 인덱스 컬럼의 유니크한 값을 모두 조회해서 주어진 쿼리에 해당 조건을 추가해서 쿼리를 다시 실행 한다.

- 두 가지 조건이 필요하다.
  - where 조건절에 조건이 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야함 (기수성이 낮아야함)
  - 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 함 (커버링 인덱스)

- 유니크한 값의 개수가 많다면 옵티마이저는 인덱스에서 스캔해야 할 시작 지점을 검색하는 작업이 많이 필요해진다. 그래서 쿼리의 성능이 더 느려질 수도 있다.
  - ex) pk의 경우 pk수 만큼 레인지 스캔 시작 지점을 검색하는 작업이 필요해진다.

- 선행 컬럼이 가진 유니크한 값의 개수가 소량일때 (기수성이 낮을 때, 선택도가 낮을 때) 적용 가능한 최적화

### 다중 컬럼 인덱스

- 2개 이상의 컬럼을 포함하는 인덱스

- 레코드 건수가 작은 경우 브랜치 노드가 없는 경우도 있을 수 있다. 루트, 리프는 항상 존재

- 인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬돼 있다.

- 인덱스 내에서 각 컬럼의 위치가 상당히 중요하다.

### B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스를 생성할 때 설정한 정렬 규칙에 따라서 인덱스의 키 값은 항ㅇ상 오름차순이거나 내림차순으로 정렬되어 저장된다.

- 어떤 인덱스가 오름차순으로 생성됐다고 해서 그 인덱스를 오름차순으로만 읽을 수 있다는 뜻은 아니다.

- 옵티마이저가 실시간으로 만들어 내는 실행 계획에 따라 방향이 결정된다.

#### 인덱스의 정렬

- 정렬 순서를 혼합한 인덱스도 생성할 수 있다.

#### 인덱스 스캔 방향

- 인덱스의 정렬 순서와 상관 없이 인덱스를 최솟값부터 읽으면 오름차순으로, 최댓값부터 거꾸로 읽으면 내림차순으로 값을 가져올 수 있다는 것을 MySQL 옵티마이저는 이미 알고 있다.

- 인덱스의 정렬은 인덱스 생성 시점에 되지만, 쿼리가 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향이 결정된다.

- 오름차순으로 생성된 인덱스를 정순으로 읽으면 오름차순으로 정렬된 결과가, 역순으로 읽으면 내림차순으로 정렬된 결과가 된다.

- order by, min, max 등에서도 읽기 방향을 전환할 수 있다.

#### 내림차순 인덱스

- 기본적으로 오름차순 인덱스가 더 성능이 좋다 (InnoDB)

- 많은 쿼리가 인덱스 앞쪽 또는 뒤쪽만 집중적으로 읽어서 인덱스의 특정 페이지 잠금이 병목 될 것으로 예상 된다면 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 좋다.

### B-Tree 인덱스의 가용성과 효율성

#### 비교 조건의 종류와 효율성

- 다중 컬럼 인덱스에서 컬럼의 순서, 조건이 동등, 크다, 작다 인지에 따라 인덱스 컬럼의 활용 형태가 달라지고, 효율도 달라진다.

- 작업 범위를 결정하는 조건: 작업 법위 결정 조건

- 단순히 거름종이 역할만 하는 조건: 필터링 조건, 체크 조건

- 작업 범위를 결정하는 조건은 많으면 많을수록 쿼리의 성능이 높아진다. 체크 조건은 많다고 해서 쿼리의 처리 성능을 높이지는 못한다.

#### 인덱스의 가용성

- B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬돼 있다.

- 하나의 컬럼으로 검색해도 값의 왼쪽 부분이 없으면 인덱스 레인지 스캔 방식의 검색이 불가능 하다.

- 다중 컬럼 인덱스에서도 왼쪽 컬럼의 값을 모르면 인덱스 레인지 스캔을 사용할 수 없다.

#### 가용성과 효율성 판단

- 다음 조건을 작ㅈ업 범위 결정 조건으로 사용할 수 없다. (체크 조건은 가능)

1. NOT_EQUAL로 비교된 경우("<>", "not in", "not between", "is not null")

2. like'%??'(앞부분이 아닌 뒷부분 일치)

3. 스토어드 함수, 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
  - where substring(column, 1, 1) = 'X'

4. NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우

5. 데이터 타입이 서로 다른 비교(인덱스 컬럼의 타입을 변환해야 비교가 가능한 경우)

6. 문자열 데이터 타입의 콜레이션이 다른 경
```
- index test (col_1, col_2, col_3... col_n)
  - 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
    - col_1에 대한 조건이 없는 경우 혹은 비교 조건이 위의 사용 불가 조건 중 하나인 경우
    
  - 작업 범위 결정 조건으로 인덱스를 사용하는 경우(i는 2보다 크고 n 보다 작은 값)
    - col_1 ~ col_(i - 1) 동등 비교 형태 (=, in)
    - col_i 동등 비교(=, in), 크다 작다(>, <), like로 좌측 일치 패턴(like 'xx%')
```







