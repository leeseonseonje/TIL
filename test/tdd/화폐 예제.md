<!-- @format -->

# 화폐 예제

## 할 일 목록

> 어떤 테스트들이 있어야 보고서에 제대로 계산 되도록 하는 코드가 완성됐다는걸 확신할 수 있을까?

```
  - 통화가 다른 두 금액을 더해서 주어진 환율에 맞게 변한 금액을 결과로 얻을 수 있어야 한다.

  - 어떤 금액(주가)을 어떤 수(주식의 수)에 곱한 금액을 결과로 얻을 수 있어야 한다.
```

-   어떤 일을 해야 하는지 알려주고, 지금 하는 일에 집중할 수 있도록 도와주며, 언제 일이 다 끝나는지 알려줄 수 있게끔 할일 목록을 작성한다.

-   또 다른 테스트가 생각나면 할 일 목록에 새로운 항목을 추가한다.

## 곱하기 먼저

-   할 일 목록(두 번째 곱하기)에 곱하기를 테스트 한다.

-   객체를 만들면서 시작하는게 아니라 테스트를 먼저 만들어야 한다.(이 사실을 항상 되뇌어야 한다.)

-   작은 것 부터 시작한다. (할 일 목록에서 첫번째보다 두번째가 더 쉬워 보이므로 먼저한다.)

-   오퍼레이션이 외부에서 어떤 식으로 보일지에 대한 이야기를 테스트 코드에 적어야 한다.

```
    describe("times") {
        context("입력값이 정수인 경우") {
            it("dollar의 amount가 입력 값 만큼 곱해진다.") {
                val sut = Dollar(5)

                sut.times(2)

                sut.amount shouldBe 10
            }
        }
    }
```

-   부작용이 있을 수 있고, 금액을 계산하는데 정수형을 사용한다. (작은 단계로 시작하는 것 뿐이다.)

-   문제들을 적어놓고 계속 진행한다.

-   현재 실패하는 테스트가 주어진 상태고 최대한 빨리 초록막대를 봐야한다.

```
문제
- Dollar 부작용?
- Money 반올림?
```

-   위의 테스트는 컴파일 조차 되지 않는다.

-   네 개의 컴파일 에러가 있다.

    1. Dollar 클래스가 없다.
    2. 생성자가 없다.
    3. times(int) 메서드가 없다.
    4. amount 필드가 없다.

-   위 문제들을 해결해서 컴파일이 되도록 한다.

```
class Dollar(amount: Int) {

    var amount = amount

    fun times(multiplier: Int) {
    }
}
```

-   위의 Dollar클래스를 추가 후 테스트를 실행하면 컴파일 되는 실패하는 테스트가 된다. (빨간 막대)

-   이제 문제는 '다중 통화 구현'에서 '이 테스트를 통과시킨 후 나머지 테스트들도 통과시키기'로 변형되었다. 훨씬 간단하고, 범위도 줄었다.

-   당장의 목표는 테스트를 통과하는 것 뿐이다.

```
var amount = 10
```

-   테스트가 성공한다.
-   다음과 같은 주기로 계속 진행한다.

```
TDD 주기
1. 작은 테스트를 하나 추가한다.
2. 모든 테스트를 실행해서 테스트가 실패하는 것을 확인한다.
3. 수정한다.
4. 모든 테스트를 실행해서 테스트가 성공하는 것을 확인한다.
5. 중복을 제거하기 위해 리팩토링을 한다.
```

> One and only once: 필요한 것을 하되 단 한 번만 하라

-   주기의 1번부터 4번 까지 수행했다. 중복을 제거 해야한다.

-   중복은 테스트에 있는 데이터와 코드에 있는 데이터 사이에 존재한다.

```
var amount = 10 를
var amount = 5 * 2로 바꾸면 테스트 코드(생성자 5, 메서드 인자 2)와 중복이 발생하게 된다.
```

-   한번에 중복을 제거할 수 있는 방법은 없다.
-   일단 객체의 초기화 단계에 있는 코드를 times() 메서드 안으로 옮긴다.

```
    fun times(multiplier: Int) {
        amount = 5 * 2
    }
```

-   테스트는 성공한다.

> TDD의 핵심은 이와 같은 작은 단계를 밟을 능력을 갖추어야 한다는 것이다.
>
> 항상 이런식의 코딩을 하진 않는다. 일이 꼬이기 시작하면 한다.
> 작은 단계로 작업하는 방법을 배우면, 저절로 적절한 크기의 단계로 작업할 수 있게 될 것이다.

-   이제 중복(5와 2)을 제거해야 한다.

-   5는 생성자에서 넘어오는 값이니 amount변수에 생성자로 넘어오는 값을 저장한다.

```
var amount = amount
```

-   amount의 변경으로 times()메서드도 다음과 같이 수정할 수 있다.

```
    fun times(multiplier: Int) {
        amount = amount * 2
    }
```

-   2의 중복을 제거할 차례다.

-   2는 인자 multiplier의 값이므로 multiplier 인자로 2를 대체한다.

```
    fun times(multiplier: Int) {
        amount *= multiplier
    }
```

-   중복 제거를 위해 \*= 연산자를 사용한다.

```
    fun times(multiplier: Int) {
        amount *= multiplier
    }
```

-   코틀린 생성자를 이용해 필트 중복을 제거한다.

```
var amount = amount // 제거
class Dollar(var amount: Int) // 변수 키워드 추가(var)
```

-   테스트는 성공한다.

```
지금까지 한 작업

- 작업해야 할 테스트 목록을 만들었다.

- 오퍼레이션이 외부에서 어떻게 보이길 원하는지 말해주는 이야기를 코드로 표현했다.

- 스텁 구현을 통해 테스트를 컴파일 했다.

- 억지로 테스트를 통과시켰다.

- 돌아가는 코드에서 상수를 변수로 변경하여 점진적으로 일반화했다.

- 새로운 할일들을 한번에 처리하는 대신 할 일 목록에 추가하고 넘어갔다.
```

## TDD 주기

1. 테스트를 작성한다.

    - 오퍼레이션이 코드에 어떤 식으로 나타나길 원하는지 써내려간다.
    - 원하는 인터페이스를 개발한다.

2. 실행 가능하게 만든다.

    - 중요한 것은 초록 막대를 빨리 보는 것이다.
    - 깔끔하고 단순한 해법이 명백히 보인다면 그것을 입력하고, 그렇지 않다면 (몇분 정도 걸릴다면)일단 적어놓은 뒤에 초록막대부터 본다.

3. 올바르게 만든다.
    - 시스템이 작동하게 만든 후 올바르게 수정한다.
    - 소프트 웨어 개발 원칙에 따라 수정하고 중복을 제거하고 초록 막대로 만든다.

> 목적은 작동하는 깔끔한 코드를 얻는 것이다.

-   작동하는 깔끔한 코드를 얻는 것은 매우 어려운 일이다.

-   그렇기 나누어서 얻어야 한다.

-   '작동하는 깔끔한 코드'에서 '직동하는'에 해당하는 부분을 먼저 해결한다.

-   이 후에 '깔끔한 코드'부분을 해결한다.

-   '깔끔한 코드'부분을 먼저 해결한 후에, '작동하는' 부분을 해결해 가는 '아키텍처 주도 개발'의 반대다.

## Dollar의 부작용

-   Dollar에 대해 연산을 수행한 후에 Dollar의 값이 바뀐다.

-   아래 테스트는 실패한다.

```
    describe("times") {
        context("입력값이 정수인 경우") {
            it("dollar의 amount가 입력 값 만큼 곱해진다.") {
                val sut = Dollar(5)

                sut.times(2)
                sut.amount shouldBe 10

                sut.times(3)
                sut.amount shouldBe 15
            }
        }
    }
```

-   times()에서 새로운 객체를 반환하게 만들면 된다.

-   times()메서드를 바꾸기 위해서 테스트 부터 수정해야한다.

```
    describe("times") {
        context("입력값이 정수인 경우") {
            it("dollar의 amount가 입력 값 만큼 곱해진다.") {
                val sut = Dollar(5)

                val productA: Dollar = sut.times(2)
                sut.amount shouldBe 10

                val productA: Dollar = sut.times(2)
                sut.amount shouldBe 15
            }
        }
    }
```

-   수정한 테스트는 컴파일이 되지 않는다. 컴파일이 될 수 있도록 Dollar를 아래와 같이 바꾼다.

```
class Dollar(var amount: Int) {

    fun times(multiplier: Int): Dollar {
        amount *= multiplier
        return Dollar(amount)
    }
}
```

-   컴파일은 성공하지만 테스트는 실패한다.

-   테스트까지 통과하도록 코드를 올바르게 수정한다.

```
class Dollar(var amount: Int) {

    fun times(multiplier: Int): Dollar {
        return Dollar(amount.times(multiplier))
    }
}
```

-   Dollar객체의 부작용을 제거했다.

-   최대한 빨리 초록막대를 보기위한 전략 2가지

    1. 가짜로 구현하기: 상수를 반환하게 만들고 진짜 코드를 얻을 때까지 단계적으로 상수를 변수로 바꾸어 간다.
    2. 명백한 구현 사용하기: 실제 구현을 입력한다.

-   두 방법을 번갈아가면서 사용한다.

-   일이 자연스럽게 잘 진행되고 내가 뭘 입력해야 할지 알 때는 명백한 구현을 한다.

-   예상치 못한 빨간 막대를 만나게 되면 뒤로 한발 물러서서 가짜로 구현하기 방벙을 사용하면서 올바른 코드로 리팩토링한다.

-   Dollar의 부작용으로 인해 실패하는 테스트가 되었다.
-   스텀 구현으로 빠르게 컴파일을 통과하도록 만들었다.
-   올바르다고 생각하는 코드를 입력하여 테스트를 통과했다.

-   느낌을 테스트로 변환하는 것은 TDD의 일반적 주제다.

## 모두를 위한 평등

-   Dollar 객체같이 객체를 값처럼 쓸 수 있는것을 값 객체 패턴(value object pattern)이라고 한다.

-   값 객체의 제약사항 중 하나는 객체의 인스턴스 변수가 생성자를 통해서 일단 설정된 후에는 결코 변하지 않는다는 것이다.

-   값 객체는 모든 연산은 새 객체를 반환해야 한다.

-   값 객체는 equals()를 구현해야 한다. (왜냐하면 값이 같은 값 객체는 똑같아야 하기 때문이다.)

### 삼각측량 전략

-   테스트 코드 작성

```
context("두 개의 Dollar객체의 값이 같을 경우") {
    it("equals는 true를 반환하다.") {
        Dollar(5).equals(Dollar(5)) shouldBe true
        }
    }
```

-   초록 막대 구현

```
override fun equals(other: Any?): Boolean {
    return true
}
```

-   삼각측량을 이용하려면 예제가 두 개 이상 있어야 코드를 일반화 할 수 있다.

-   두 번째 예제

```
context("두 개의 Dollar객체의 값이 같을 경우") {
    it("equals는 true를 반환하다.") {
        Dollar(5).equals(Dollar(5)) shouldBe true
        Dollar(5).equals(Dollar(6)) shouldBe false
    }
}
```

-   코드를(equals())를 일반화 한다.

```
override fun equals(other: Any?): Boolean {
    return true
}
```

-   리팩토링을 어떻게 하는지 감이 안 올 때 사용
-   Dollar의 동질성을 비교할 수 있게 됐다.

-   Dollar의 amount를 불변으로 만들었다.

-   곱하기 테스트 리팩토링

```
context("입력값이 정수인 경우") {
    it("dollar의 amount가 입력 값 만큼 곱해진다.") {
        val sut = Dollar(5)

        sut.times(2) shouldBe Dollar(10)
        sut.times(3) shouldBe Dollar(15)
    }
}
```

-   만약 동치성 테스트가 동치성에 대한 코드가 정확히 작동한다는 것을 검증하는데 실패한다면, 곱하기 테스트 역시 곱하기에 대한 코드가 정확하게 작동한다는 것을 검증하는데 실패하게 된다.

-   TDD를 하면서 적극적으로 관리해야 할 위험 요소다.

-   완벽함을 위해 노력하지 않는다.

-   모든 것을 두 번 말 함으로써(코드, 테스트) 자신감을 준다.

-   결함이 발생할 수 있다.

## Fanc 객체 만들기

-   Dollar대신 Franc을 표현할 수 있는 객체가 필요하다.

-   Dollar객체와 비슷하게 작동한다면 Dollar테스트를 복사한 후 수정하면 된다.

```
    describe("franc") {
        context("입력값이 정수인 경우") {
            it("franc의 amount가 입력 값 만큼 곱해진다.") {
                val sut = Franc(5)

                sut.times(2) shouldBe Franc(10)
                sut.times(3) shouldBe Franc(15)
            }
        }

        context("두 개의 franc객체의 값이 같을 경우") {
            it("equals는 true를 반환하다.") {
                Franc(5).equals(Franc(5)) shouldBe true
                Franc(5).equals(Franc(6)) shouldBe false
            }
        }
    }
```

1. 테스트 작성
2. 컴파일되게 하기
3. 실패하는지 확인하기 위해 실행
4. 실행하게 만듦
5. 중복제거

-   처음 네 단계는 빨리 진행해야 한다.

-   속도가 가장 중요하다.

```
class Franc(private val amount: Int) {

    fun times(multiplier: Int): Franc {
        return Franc(amount.times(multiplier))
    }

    override fun equals(other: Any?): Boolean {
        val franc: Franc = other as Franc
        return this.amount == franc.amount
    }
}
```

-   중복이 많기 때문에 이것들을 제거해야 한다.

```
-   큰 테스트를 공략할 수 없다. 그래서 진전을 나타낼 수 있는 자그마한 테스트를 만들었다.

-   중복을 만들고 조금 고쳐서 테스트를 작성했다.

-   모델 코드를 복사하고 수정해서 테스트를 통과했다.
```

-   중복을 제거하기 위해 두 클래스(Dollar, Franc)의 공통 상위 클래스인 Money클래스를 만든다.

```
class Money {
}
```

-   Money클래스를 추가해도 테스트는 잘 돌아간다.

-   Dollar가 Money를 상속받게 한다.

```
class Dollar(private val amount: Int) : Money() {

    fun times(multiplier: Int): Dollar {
        return Dollar(amount.times(multiplier))
    }

    override fun equals(other: Any?): Boolean {
        val dollar: Dollar = other as Dollar
        return this.amount == dollar.amount
    }
}
```

-   테스트는 잘 작동한다. amount를 Money로 옮긴다.

```
open class Money(protected val amount: Int) {
}

class Dollar(amount: Int) : Money(amount) {

    fun times(multiplier: Int): Dollar {
        return Dollar(amount.times(multiplier))
    }

    override fun equals(other: Any?): Boolean {
        val dollar: Dollar = other as Dollar
        return this.amount == dollar.amount
    }
}
```

-   테스트는 잘 작동한다. 이제 equals() 코드를 Money로 옮긴다.

```
open class Money(protected val amount: Int) {

    override fun equals(other: Any?): Boolean {
        val dollar: Dollar = other as Dollar
        return this.amount == dollar.amount
    }
}
```

-   테스트는 잘 작동한다. 이제 cast부분을 변경한다.

```
open class Money(protected val amount: Int) {

    override fun equals(other: Any?): Boolean {
        val money: Money = other as Money
        return this.amount == money.amount
    }
}
```

-   테스트는 잘 작동한다.

-   Franc에 equals를 제거한다.

-   현재 동치성 테스트가 Franc끼리의 비교에 대해서는 다루지 않는다.

-   적절한 테스트를 갖지 못한 코드에서 TDD를 해야 하는 경우가 종종 있다.

-   테스트가 갖춰지지 않은 상태에서 리팩토링을 하게되면 실수를 했는데도 테스트가 통과할 수도 있다.

-   이럴 땐 있으면 좋을 것 같은 테스트를 적상해야한다. 그렇지 않으면 리팩토링이 뭔가를 깨트릴 것이다.

```
    describe("money") {
        context("money를 상속한 자식클래스의 경우") {
            it("동치성을 보장한다.") {
                Dollar(5).equals(Dollar(5)) shouldBe true
                Dollar(5).equals(Dollar(6)) shouldBe false
                Franc(5).equals(Franc(5)) shouldBe true
                Franc(5).equals(Franc(6)) shouldBe false
            }
            }
        }
```

-   Franc클래스를 Money클래스를 상속하게 만든다.

```
class Franc(amount: Int) : Money(amount) {

    fun times(multiplier: Int): Franc {
        return Franc(amount.times(multiplier))
    }

    override fun equals(other: Any?): Boolean {
        val franc: Franc = other as Franc
        return this.amount == franc.amount
    }
}
```

-   Franc의 equals와 Money의 equals는 비슷하다. 이 두 부분을 똑같이 만들 수 있으면 프로그램의 의미를 변화시키지 않고도 Franc의 equals()를 지울 수 있게 된다.

```
class Franc(amount: Int) : Money(amount) {

    fun times(multiplier: Int): Franc {
        return Franc(amount.times(multiplier))
    }

    override fun equals(other: Any?): Boolean {
        val money: Money = other as Money
        return this.amount == money.amount
    }
}
```

-   테스트가 모두 통과한다. 이제 Franc와 Money의 equals가 동일하기 때문에 franc의 equals를 제거한다.

```
- 공통된 코드를 Dollar클래스에서 Money로 올렸다.

- Franc도 Money의 하위 클래스로 만들었다.

- 불필요한 구현을 제거하기 전에 두 equals()구현을 일치시켰다.
```

-   다음 테스트는 실패한다.

```
Franc(5).equals(Dollar(5)) shouldBe false
```

-   오직 금액과 클래스가 서로 동일할 경우에만 두 Money가 서로 같아야 한다.

```
    override fun equals(other: Any?): Boolean {
        val money: Money = other as Money
        return this.amount == money.amount
                && this.javaClass.equals(money.javaClass)
    }
```

-   테스트는 성공한다.

-   더 많은 동기가 있기 전에는 더 많은 설계를 도입하지 않는다.

-   Dollar와 Franc의 times() 메서드는 거의 동일하다.

-   반환 값을 Money로 바꾸면 더 비슷하게 된다.

```
    fun times(multiplier: Int): Money {
        return Dollar(amount.times(multiplier))
    }

        fun times(multiplier: Int): Money {
        return Franc(amount.times(multiplier))
    }
```

-   하위 클래스에 직접적인 참조가 적어진다면 하위 클래스를 제거하기 위해 한 발짝 더 다가섰다고 할 수 있다. Money에 Dollar를 반환하는 팩토리 메서드를 도입할 수 있다.

```
    companion object {
        fun dollar(amount: Int): Dollar {
            return Dollar(amount)
        }
    }
```

-   테스트를 다음과 같이 변경한다.

```
        context("입력값이 정수인 경우") {
            it("dollar의 amount가 입력 값 만큼 곱해진다.") {
                val sut: Money = Money.dollar(5)

                sut.times(2) shouldBe Dollar(10)
                sut.times(3) shouldBe Dollar(15)
            }
        }
```

-   times()가 없다고 나온다.

-   Money를 추상 클래스로 변경한다.

```
abstract class Money(protected val amount: Int) {

    abstract fun times(multiplier: Int): Money
}
```

-   팩토리 메서드의 선언을 바꾼다.

```
    companion object {
        fun dollar(amount: Int): Money {
            return Dollar(amount)
        }
    }
```
